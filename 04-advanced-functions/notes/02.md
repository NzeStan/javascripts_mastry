# Module 04 - Lesson 2: Closures & Scope

## What is Scope?

**Scope** determines where variables can be accessed in your code. Think of it as variable "visibility zones"!

### Three Types of Scope

```javascript
// 1. GLOBAL SCOPE - Accessible everywhere
let globalVar = "I'm global!";

function test() {
    // 2. FUNCTION SCOPE - Only inside this function
    let functionVar = "I'm local to function!";
    
    if (true) {
        // 3. BLOCK SCOPE - Only inside this block
        let blockVar = "I'm local to block!";
        
        console.log(globalVar);      // ‚úÖ Works
        console.log(functionVar);    // ‚úÖ Works
        console.log(blockVar);       // ‚úÖ Works
    }
    
    console.log(globalVar);      // ‚úÖ Works
    console.log(functionVar);    // ‚úÖ Works
    // console.log(blockVar);    // ‚ùå Error! Out of scope
}

console.log(globalVar);      // ‚úÖ Works
// console.log(functionVar); // ‚ùå Error! Out of scope
// console.log(blockVar);    // ‚ùå Error! Out of scope
```

---

## Global Scope

Variables declared outside any function or block.

```javascript
// Global variables
let name = "Ifeanyi";
const PI = 3.14159;

function greet() {
    // Can access global variables
    console.log("Hello, " + name);
}

function calculateCircle(radius) {
    // Can access PI
    return PI * radius * radius;
}

greet();  // "Hello, Ifeanyi"
console.log(calculateCircle(5));  // 78.53975
```

**‚ö†Ô∏è Avoid too many globals!**
```javascript
// ‚ùå BAD - Pollutes global scope
let counter = 0;
let data = [];
let config = {};

// ‚úÖ GOOD - Use one global object
let app = {
    counter: 0,
    data: [],
    config: {}
};
```

---

## Function Scope

Variables declared inside a function are local to that function.

```javascript
function calculateTotal() {
    // Local variables
    let price = 100;
    let tax = 0.1;
    let total = price + (price * tax);
    
    return total;
}

console.log(calculateTotal());  // 110
// console.log(price);          // ‚ùå Error! price is not defined
// console.log(tax);            // ‚ùå Error! tax is not defined
// console.log(total);          // ‚ùå Error! total is not defined
```

### var vs let/const in Functions

```javascript
function testVar() {
    if (true) {
        var x = 10;      // Function-scoped
        let y = 20;      // Block-scoped
        const z = 30;    // Block-scoped
    }
    
    console.log(x);  // ‚úÖ 10 (var is function-scoped)
    // console.log(y);  // ‚ùå Error! (let is block-scoped)
    // console.log(z);  // ‚ùå Error! (const is block-scoped)
}

testVar();
```

---

## Block Scope

Created by `{}` curly braces with `let` and `const`.

```javascript
// if block
if (true) {
    let blockVar = "I'm in the block";
    console.log(blockVar);  // ‚úÖ Works
}
// console.log(blockVar);  // ‚ùå Error! Out of scope

// for loop block
for (let i = 0; i < 3; i++) {
    let loopVar = "Loop " + i;
    console.log(loopVar);  // ‚úÖ Works
}
// console.log(i);        // ‚ùå Error! Out of scope
// console.log(loopVar);  // ‚ùå Error! Out of scope

// Standalone block
{
    let isolated = "Isolated variable";
    console.log(isolated);  // ‚úÖ Works
}
// console.log(isolated);  // ‚ùå Error! Out of scope
```

---

## Lexical Scope (Static Scope)

Inner functions can access outer function variables!

```javascript
function outer() {
    let outerVar = "I'm from outer";
    
    function inner() {
        let innerVar = "I'm from inner";
        
        // Can access both!
        console.log(outerVar);  // ‚úÖ "I'm from outer"
        console.log(innerVar);  // ‚úÖ "I'm from inner"
    }
    
    inner();
    // console.log(innerVar);  // ‚ùå Error! Can't access inner
}

outer();
```

### Nested Functions

```javascript
function grandparent() {
    let gpVar = "grandparent";
    
    function parent() {
        let pVar = "parent";
        
        function child() {
            let cVar = "child";
            
            // Child can access all!
            console.log(gpVar);  // ‚úÖ "grandparent"
            console.log(pVar);   // ‚úÖ "parent"
            console.log(cVar);   // ‚úÖ "child"
        }
        
        child();
    }
    
    parent();
}

grandparent();
```

---

## What Are Closures?

A **closure** is a function that has access to variables from an outer function, even after the outer function has finished executing!

### Simple Closure

```javascript
function createGreeter(greeting) {
    // 'greeting' is in outer function
    
    return function(name) {
        // Inner function can access 'greeting'
        console.log(greeting + ", " + name + "!");
    };
}

// Create greeter functions
let sayHello = createGreeter("Hello");
let sayHi = createGreeter("Hi");

// Use them later - outer function is done, but...
sayHello("Ifeanyi");  // "Hello, Ifeanyi!"
sayHi("Sarah");       // "Hi, Sarah!"

// 'greeting' is still accessible! This is closure!
```

**Key Point:** The inner function "remembers" the variables from its outer scope!

---

## Why Closures Matter

### 1. Data Privacy

```javascript
function createCounter() {
    // Private variable - can't access from outside!
    let count = 0;
    
    return {
        increment() {
            count++;
            console.log(count);
        },
        decrement() {
            count--;
            console.log(count);
        },
        getCount() {
            return count;
        }
    };
}

let counter = createCounter();
counter.increment();  // 1
counter.increment();  // 2
counter.decrement();  // 1
console.log(counter.getCount());  // 1

// Can't access count directly!
// console.log(counter.count);  // undefined
// count++;  // Error! count is not defined
```

### 2. Function Factories

```javascript
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

let double = createMultiplier(2);
let triple = createMultiplier(3);
let quadruple = createMultiplier(4);

console.log(double(5));      // 10
console.log(triple(5));      // 15
console.log(quadruple(5));   // 20

// Each function remembers its own 'factor'!
```

### 3. Event Handlers with Context

```javascript
function createButton(label) {
    let clickCount = 0;
    
    return {
        render() {
            let button = document.createElement('button');
            button.textContent = label;
            
            button.addEventListener('click', function() {
                // Closure! Can access clickCount and label
                clickCount++;
                console.log(`${label} clicked ${clickCount} times`);
            });
            
            document.body.appendChild(button);
        }
    };
}

let btn1 = createButton("Button 1");
let btn2 = createButton("Button 2");

btn1.render();
btn2.render();

// Each button has its own clickCount!
```

---

## Closure Examples

### Example 1: Bank Account

```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;  // Private!
    
    return {
        deposit(amount) {
            if (amount > 0) {
                balance += amount;
                console.log(`Deposited $${amount}. Balance: $${balance}`);
            }
        },
        
        withdraw(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                console.log(`Withdrew $${amount}. Balance: $${balance}`);
            } else {
                console.log("Insufficient funds!");
            }
        },
        
        getBalance() {
            return balance;
        }
    };
}

let account = createBankAccount(1000);
account.deposit(500);      // Deposited $500. Balance: $1500
account.withdraw(200);     // Withdrew $200. Balance: $1300
console.log(account.getBalance());  // 1300

// Can't directly modify balance!
// account.balance = 999999;  // Doesn't work!
console.log(account.getBalance());  // Still 1300
```

### Example 2: Configuration Manager

```javascript
function createConfig() {
    let settings = {
        theme: 'light',
        language: 'en',
        notifications: true
    };
    
    return {
        get(key) {
            return settings[key];
        },
        
        set(key, value) {
            settings[key] = value;
            console.log(`Updated ${key} to ${value}`);
        },
        
        getAll() {
            // Return copy, not original!
            return { ...settings };
        }
    };
}

let config = createConfig();
console.log(config.get('theme'));  // 'light'
config.set('theme', 'dark');       // Updated theme to dark
console.log(config.getAll());       // { theme: 'dark', language: 'en', ... }
```

### Example 3: Timer Manager

```javascript
function createTimer(name) {
    let seconds = 0;
    let intervalId = null;
    
    return {
        start() {
            if (!intervalId) {
                intervalId = setInterval(() => {
                    seconds++;
                    console.log(`${name}: ${seconds}s`);
                }, 1000);
            }
        },
        
        stop() {
            if (intervalId) {
                clearInterval(intervalId);
                intervalId = null;
                console.log(`${name} stopped at ${seconds}s`);
            }
        },
        
        reset() {
            this.stop();
            seconds = 0;
            console.log(`${name} reset`);
        },
        
        getTime() {
            return seconds;
        }
    };
}

let timer = createTimer("Timer 1");
timer.start();
// Timer 1: 1s
// Timer 1: 2s
// Timer 1: 3s
setTimeout(() => timer.stop(), 3500);
// Timer 1 stopped at 3s
```

### Example 4: ID Generator

```javascript
function createIdGenerator(prefix) {
    let id = 0;
    
    return function() {
        id++;
        return `${prefix}-${id}`;
    };
}

let userId = createIdGenerator("USER");
let productId = createIdGenerator("PROD");

console.log(userId());     // "USER-1"
console.log(userId());     // "USER-2"
console.log(productId());  // "PROD-1"
console.log(userId());     // "USER-3"
console.log(productId());  // "PROD-2"

// Each generator has its own counter!
```

---

## Common Closure Pitfalls

### Pitfall 1: Loop Variable Problem

```javascript
// ‚ùå PROBLEM - All functions reference same 'i'
function createButtons() {
    for (var i = 1; i <= 3; i++) {
        let button = document.createElement('button');
        button.textContent = 'Button ' + i;
        
        button.addEventListener('click', function() {
            alert('Button ' + i);  // Always shows 4!
        });
        
        document.body.appendChild(button);
    }
}

// ‚úÖ SOLUTION 1 - Use 'let' instead of 'var'
function createButtonsFixed1() {
    for (let i = 1; i <= 3; i++) {  // 'let' creates new scope
        let button = document.createElement('button');
        button.textContent = 'Button ' + i;
        
        button.addEventListener('click', function() {
            alert('Button ' + i);  // Correct number!
        });
        
        document.body.appendChild(button);
    }
}

// ‚úÖ SOLUTION 2 - Use IIFE (Immediately Invoked Function Expression)
function createButtonsFixed2() {
    for (var i = 1; i <= 3; i++) {
        (function(num) {  // Create closure with current i
            let button = document.createElement('button');
            button.textContent = 'Button ' + num;
            
            button.addEventListener('click', function() {
                alert('Button ' + num);  // Correct number!
            });
            
            document.body.appendChild(button);
        })(i);
    }
}
```

### Pitfall 2: Memory Leaks

```javascript
// ‚ùå PROBLEM - Closure keeps reference, prevents garbage collection
function attachEvents() {
    let bigData = new Array(1000000).fill('data');
    
    document.getElementById('btn').addEventListener('click', function() {
        console.log('Clicked');
        // bigData is captured but never used - memory leak!
    });
}

// ‚úÖ SOLUTION - Only capture what you need
function attachEventsFixed() {
    let dataLength = new Array(1000000).fill('data').length;
    
    document.getElementById('btn').addEventListener('click', function() {
        console.log('Clicked');
        console.log('Data length was:', dataLength);
        // Only captures dataLength, not entire array
    });
}
```

---

## Practical Closure Patterns

### Pattern 1: Module Pattern

```javascript
let calculator = (function() {
    // Private variables and functions
    let result = 0;
    
    function log(operation, value) {
        console.log(`${operation}: ${value}, Result: ${result}`);
    }
    
    // Public API
    return {
        add(n) {
            result += n;
            log('Add', n);
            return this;
        },
        
        subtract(n) {
            result -= n;
            log('Subtract', n);
            return this;
        },
        
        multiply(n) {
            result *= n;
            log('Multiply', n);
            return this;
        },
        
        divide(n) {
            if (n !== 0) {
                result /= n;
                log('Divide', n);
            }
            return this;
        },
        
        getResult() {
            return result;
        },
        
        reset() {
            result = 0;
            console.log('Reset');
            return this;
        }
    };
})();

// Chainable API!
calculator
    .add(10)        // Add: 10, Result: 10
    .multiply(2)    // Multiply: 2, Result: 20
    .subtract(5)    // Subtract: 5, Result: 15
    .divide(3);     // Divide: 3, Result: 5

console.log(calculator.getResult());  // 5
```

### Pattern 2: Singleton Pattern

```javascript
let userManager = (function() {
    let instance = null;
    let currentUser = null;
    
    function createInstance() {
        return {
            login(username, password) {
                // Simulate login
                if (username && password) {
                    currentUser = {
                        username: username,
                        loggedInAt: new Date()
                    };
                    return true;
                }
                return false;
            },
            
            logout() {
                currentUser = null;
            },
            
            getCurrentUser() {
                return currentUser;
            },
            
            isLoggedIn() {
                return currentUser !== null;
            }
        };
    }
    
    return {
        getInstance() {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();

// Always get same instance
let manager1 = userManager.getInstance();
let manager2 = userManager.getInstance();

manager1.login('ifeanyi', '12345');
console.log(manager2.isLoggedIn());  // true (same instance!)
```

### Pattern 3: Partial Application

```javascript
function multiply(a, b) {
    return a * b;
}

function partial(fn, ...fixedArgs) {
    return function(...remainingArgs) {
        return fn(...fixedArgs, ...remainingArgs);
    };
}

let double = partial(multiply, 2);
let triple = partial(multiply, 3);

console.log(double(5));   // 10
console.log(triple(5));   // 15

// Real example: API calls
function makeRequest(method, url, data) {
    console.log(`${method} ${url}`, data);
}

let get = partial(makeRequest, 'GET');
let post = partial(makeRequest, 'POST');

get('/users');              // GET /users
post('/users', {name: 'John'});  // POST /users { name: 'John' }
```

---

## Scope Chain

How JavaScript looks up variables:

```javascript
let global = "global";

function outer() {
    let outerVar = "outer";
    
    function inner() {
        let innerVar = "inner";
        
        console.log(innerVar);  // 1. Check inner scope ‚úÖ
        console.log(outerVar);  // 2. Check outer scope ‚úÖ
        console.log(global);    // 3. Check global scope ‚úÖ
        // console.log(unknown); // 4. Not found - Error!
    }
    
    inner();
}

outer();
```

---

## Practice Exercises

```javascript
// Exercise 1: Create a private variable counter
function createSecureCounter() {
    let count = 0;
    const password = "secret";
    
    return {
        increment(pwd) {
            if (pwd === password) {
                count++;
                return count;
            }
            return "Access denied";
        },
        
        decrement(pwd) {
            if (pwd === password) {
                count--;
                return count;
            }
            return "Access denied";
        },
        
        getValue(pwd) {
            if (pwd === password) {
                return count;
            }
            return "Access denied";
        }
    };
}

let counter = createSecureCounter();
console.log(counter.increment("secret"));  // 1
console.log(counter.increment("wrong"));   // "Access denied"

// Exercise 2: Create a memoization function
function memoize(fn) {
    const cache = {};
    
    return function(arg) {
        if (cache[arg] !== undefined) {
            console.log("From cache");
            return cache[arg];
        }
        
        console.log("Computing...");
        const result = fn(arg);
        cache[arg] = result;
        return result;
    };
}

function slowSquare(n) {
    // Simulate slow operation
    for (let i = 0; i < 1000000000; i++) {}
    return n * n;
}

let fastSquare = memoize(slowSquare);
console.log(fastSquare(5));  // Computing... ‚Üí 25 (slow)
console.log(fastSquare(5));  // From cache ‚Üí 25 (instant!)

// Exercise 3: Create a rate limiter
function createRateLimiter(maxCalls, timeWindow) {
    let calls = [];
    
    return function(fn) {
        const now = Date.now();
        
        // Remove old calls outside time window
        calls = calls.filter(time => now - time < timeWindow);
        
        if (calls.length < maxCalls) {
            calls.push(now);
            fn();
            return true;
        } else {
            console.log("Rate limit exceeded!");
            return false;
        }
    };
}

let limiter = createRateLimiter(3, 5000);  // 3 calls per 5 seconds

limiter(() => console.log("Call 1"));  // Call 1
limiter(() => console.log("Call 2"));  // Call 2
limiter(() => console.log("Call 3"));  // Call 3
limiter(() => console.log("Call 4"));  // Rate limit exceeded!
```

---

## Key Takeaways ‚úì

- [ ] Scope determines variable accessibility
- [ ] Three types: global, function, block scope
- [ ] Lexical scope: inner functions access outer variables
- [ ] Closures remember outer scope even after function returns
- [ ] Use closures for data privacy
- [ ] Closures enable function factories
- [ ] Be aware of closure memory implications
- [ ] Module pattern uses closures for encapsulation

**Next:** Arrow Functions Deep Dive! Open `03-arrow-functions.md` üí™