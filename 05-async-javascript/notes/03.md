# Module 05 - Lesson 3: Async/Await

## What is Async/Await?

**async/await** is syntactic sugar over Promises that makes async code look and behave like synchronous code!

**Benefits:**
- ‚úÖ Cleaner, more readable code
- ‚úÖ Works with try/catch for errors
- ‚úÖ Easier to debug
- ‚úÖ Less .then() chaining

**Remember:** async/await is still promises under the hood!

---

## The async Keyword

`async` before a function makes it **return a promise**:

```javascript
// Regular function
function regularFunction() {
    return "Hello";
}

// Async function
async function asyncFunction() {
    return "Hello";
}

console.log(regularFunction());  // "Hello"
console.log(asyncFunction());    // Promise {<fulfilled>: "Hello"}

// Use with .then()
asyncFunction().then(result => {
    console.log(result);  // "Hello"
});
```

**Any value returned becomes the resolved value of the promise:**

```javascript
async function getNumber() {
    return 42;
}

// Equivalent to:
function getNumber() {
    return Promise.resolve(42);
}
```

---

## The await Keyword

`await` **pauses** execution until a promise resolves:

```javascript
async function fetchData() {
    console.log("Start");
    
    // Wait for promise to resolve
    const result = await Promise.resolve("Data");
    
    console.log("Result:", result);
    console.log("End");
}

fetchData();
// Output:
// Start
// Result: Data
// End
```

**‚ö†Ô∏è Important:** `await` can only be used inside `async` functions!

```javascript
// ‚ùå WRONG
function normalFunction() {
    const result = await fetchData();  // Error!
}

// ‚úÖ CORRECT
async function asyncFunction() {
    const result = await fetchData();  // Works!
}
```

---

## Basic async/await Examples

### Example 1: Simple Fetch

```javascript
// With Promises
function getUserPromise(id) {
    return fetch(`/api/users/${id}`)
        .then(response => response.json())
        .then(user => {
            console.log("User:", user);
            return user;
        })
        .catch(error => {
            console.error("Error:", error);
        });
}

// With async/await (cleaner!)
async function getUserAsync(id) {
    try {
        const response = await fetch(`/api/users/${id}`);
        const user = await response.json();
        console.log("User:", user);
        return user;
    } catch (error) {
        console.error("Error:", error);
    }
}
```

### Example 2: Multiple Sequential Requests

```javascript
// With Promises (verbose)
function loadUserDataPromise(userId) {
    return fetchUser(userId)
        .then(user => {
            console.log("1. User:", user);
            return fetchPosts(user.id);
        })
        .then(posts => {
            console.log("2. Posts:", posts);
            return fetchComments(posts[0].id);
        })
        .then(comments => {
            console.log("3. Comments:", comments);
            return comments;
        })
        .catch(error => {
            console.error("Error:", error);
        });
}

// With async/await (readable!)
async function loadUserDataAsync(userId) {
    try {
        const user = await fetchUser(userId);
        console.log("1. User:", user);
        
        const posts = await fetchPosts(user.id);
        console.log("2. Posts:", posts);
        
        const comments = await fetchComments(posts[0].id);
        console.log("3. Comments:", comments);
        
        return comments;
    } catch (error) {
        console.error("Error:", error);
    }
}
```

---

## Error Handling

### Using try/catch

```javascript
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const user = await response.json();
        return user;
    } catch (error) {
        console.error("Failed to fetch user:", error.message);
        throw error;  // Re-throw if you want caller to handle
    }
}

// Usage
fetchUserData(1)
    .then(user => console.log("User:", user))
    .catch(error => console.error("Caught in caller:", error));
```

### Multiple try/catch Blocks

```javascript
async function loadData() {
    let user, posts, comments;
    
    try {
        user = await fetchUser(1);
        console.log("User loaded");
    } catch (error) {
        console.error("User failed:", error);
        user = { id: 1, name: "Default User" };  // Fallback
    }
    
    try {
        posts = await fetchPosts(user.id);
        console.log("Posts loaded");
    } catch (error) {
        console.error("Posts failed:", error);
        posts = [];  // Fallback
    }
    
    try {
        comments = await fetchComments(posts[0]?.id || 1);
        console.log("Comments loaded");
    } catch (error) {
        console.error("Comments failed:", error);
        comments = [];  // Fallback
    }
    
    return { user, posts, comments };
}
```

### finally Block

```javascript
async function loadWithIndicator() {
    let isLoading = true;
    console.log("‚è≥ Loading...");
    
    try {
        const data = await fetchData();
        console.log("Data:", data);
        return data;
    } catch (error) {
        console.error("Error:", error);
        throw error;
    } finally {
        isLoading = false;
        console.log("‚úÖ Loading complete!");
    }
}
```

---

## Parallel Execution

### Sequential (Slow) ‚ùå

```javascript
async function sequentialFetch() {
    const start = Date.now();
    
    const user = await fetchUser(1);      // Wait 1 second
    const posts = await fetchPosts(1);    // Wait 1 second
    const comments = await fetchComments(1); // Wait 1 second
    
    const elapsed = Date.now() - start;
    console.log(`Sequential: ${elapsed}ms`);  // ~3000ms
    
    return { user, posts, comments };
}
```

### Parallel (Fast) ‚úÖ

```javascript
async function parallelFetch() {
    const start = Date.now();
    
    // Start all requests at once (don't await yet!)
    const userPromise = fetchUser(1);
    const postsPromise = fetchPosts(1);
    const commentsPromise = fetchComments(1);
    
    // Now await all of them
    const user = await userPromise;
    const posts = await postsPromise;
    const comments = await commentsPromise;
    
    const elapsed = Date.now() - start;
    console.log(`Parallel: ${elapsed}ms`);  // ~1000ms
    
    return { user, posts, comments };
}
```

### Using Promise.all() with async/await

```javascript
async function parallelWithAll() {
    const start = Date.now();
    
    const [user, posts, comments] = await Promise.all([
        fetchUser(1),
        fetchPosts(1),
        fetchComments(1)
    ]);
    
    const elapsed = Date.now() - start;
    console.log(`Promise.all: ${elapsed}ms`);  // ~1000ms
    
    return { user, posts, comments };
}
```

---

## Real-World Patterns

### Pattern 1: Retry Logic

```javascript
async function fetchWithRetry(url, maxRetries = 3, delay = 1000) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`Attempt ${attempt}/${maxRetries}`);
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error(`Attempt ${attempt} failed:`, error.message);
            
            if (attempt === maxRetries) {
                throw new Error(`Failed after ${maxRetries} attempts`);
            }
            
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Usage
fetchWithRetry("/api/unstable")
    .then(data => console.log("Success:", data))
    .catch(error => console.error("Final error:", error));
```

### Pattern 2: Timeout

```javascript
function timeout(ms) {
    return new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Timeout")), ms);
    });
}

async function fetchWithTimeout(url, ms) {
    try {
        const response = await Promise.race([
            fetch(url),
            timeout(ms)
        ]);
        return await response.json();
    } catch (error) {
        if (error.message === "Timeout") {
            console.error("Request timed out!");
        }
        throw error;
    }
}

// Usage
fetchWithTimeout("/api/slow", 5000)
    .then(data => console.log("Data:", data))
    .catch(error => console.error("Error:", error));
```

### Pattern 3: Queue Processing

```javascript
async function processQueue(items, processItem) {
    const results = [];
    
    for (const item of items) {
        console.log("Processing:", item);
        const result = await processItem(item);
        results.push(result);
    }
    
    return results;
}

// Usage
const urls = [
    "/api/data1",
    "/api/data2",
    "/api/data3"
];

processQueue(urls, async (url) => {
    const response = await fetch(url);
    return await response.json();
})
.then(results => {
    console.log("All processed:", results);
});
```

### Pattern 4: Concurrent Limit

```javascript
async function fetchWithLimit(urls, limit) {
    const results = [];
    const executing = [];
    
    for (const url of urls) {
        const promise = fetch(url).then(r => r.json());
        results.push(promise);
        
        if (limit <= urls.length) {
            const executing_promise = promise.then(() => {
                executing.splice(executing.indexOf(executing_promise), 1);
            });
            executing.push(executing_promise);
            
            if (executing.length >= limit) {
                await Promise.race(executing);
            }
        }
    }
    
    return Promise.all(results);
}

// Usage: Process 10 URLs, max 3 at a time
const urls = Array.from({ length: 10 }, (_, i) => `/api/data${i}`);
fetchWithLimit(urls, 3)
    .then(results => console.log("All done:", results));
```

### Pattern 5: Progress Tracking

```javascript
async function downloadFilesWithProgress(urls) {
    let completed = 0;
    const total = urls.length;
    
    const promises = urls.map(async (url) => {
        const response = await fetch(url);
        const blob = await response.blob();
        
        completed++;
        const percent = Math.round((completed / total) * 100);
        console.log(`Progress: ${percent}% (${completed}/${total})`);
        
        return blob;
    });
    
    return Promise.all(promises);
}

// Usage
const files = [
    "/files/file1.pdf",
    "/files/file2.pdf",
    "/files/file3.pdf"
];

downloadFilesWithProgress(files)
    .then(blobs => console.log("Downloaded:", blobs));
```

---

## Advanced Examples

### Example 1: Waterfall with Dependencies

```javascript
async function waterfall() {
    try {
        // Each step depends on previous
        const step1 = await performStep1();
        console.log("Step 1:", step1);
        
        const step2 = await performStep2(step1);
        console.log("Step 2:", step2);
        
        const step3 = await performStep3(step2);
        console.log("Step 3:", step3);
        
        return step3;
    } catch (error) {
        console.error("Waterfall failed at:", error);
        throw error;
    }
}
```

### Example 2: Race with Fallback

```javascript
async function fetchFromFastestServer() {
    const servers = [
        "https://server1.com/api/data",
        "https://server2.com/api/data",
        "https://server3.com/api/data"
    ];
    
    try {
        const response = await Promise.race(
            servers.map(url => fetch(url))
        );
        return await response.json();
    } catch (error) {
        console.error("All servers failed:", error);
        throw error;
    }
}
```

### Example 3: Batch Processing

```javascript
async function processBatches(items, batchSize, processBatch) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        console.log(`Processing batch ${i / batchSize + 1}`);
        
        const batchResults = await processBatch(batch);
        results.push(...batchResults);
        
        // Optional: delay between batches
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return results;
}

// Usage
const items = Array.from({ length: 100 }, (_, i) => i);

processBatches(items, 10, async (batch) => {
    // Process 10 items at a time
    return Promise.all(batch.map(item => processItem(item)));
})
.then(results => console.log("All batches done:", results));
```

### Example 4: Conditional Async

```javascript
async function loadUserData(userId, includeDetails = false) {
    const user = await fetchUser(userId);
    
    if (includeDetails) {
        // Only fetch these if needed
        const [posts, friends, settings] = await Promise.all([
            fetchPosts(user.id),
            fetchFriends(user.id),
            fetchSettings(user.id)
        ]);
        
        return { ...user, posts, friends, settings };
    }
    
    return user;
}

// Usage
const basicUser = await loadUserData(1);
const detailedUser = await loadUserData(1, true);
```

---

## Top-Level await

**Modern browsers and Node.js** support await outside async functions in modules:

```javascript
// In a module (.mjs file or with type="module")
const data = await fetch("/api/data");
const json = await data.json();
console.log(json);

// NO async function wrapper needed!
```

**Browser support:**
```html
<script type="module">
    const response = await fetch("/api/data");
    const data = await response.json();
    console.log(data);
</script>
```

---

## Common Mistakes

### ‚ùå Mistake 1: Forgetting await

```javascript
// WRONG
async function getUser() {
    const user = fetchUser(1);  // Forgot await!
    console.log(user);  // Promise, not user data
}

// CORRECT
async function getUser() {
    const user = await fetchUser(1);
    console.log(user);  // Actual user data
}
```

### ‚ùå Mistake 2: Sequential when parallel would work

```javascript
// WRONG (slow)
async function loadData() {
    const users = await fetchUsers();      // Wait
    const posts = await fetchPosts();      // Wait
    const comments = await fetchComments(); // Wait
    // These don't depend on each other!
}

// CORRECT (fast)
async function loadData() {
    const [users, posts, comments] = await Promise.all([
        fetchUsers(),
        fetchPosts(),
        fetchComments()
    ]);
}
```

### ‚ùå Mistake 3: Not handling errors

```javascript
// WRONG
async function getData() {
    const data = await fetch("/api/data");
    return data.json();
    // If fetch fails, unhandled promise rejection!
}

// CORRECT
async function getData() {
    try {
        const data = await fetch("/api/data");
        return await data.json();
    } catch (error) {
        console.error("Failed:", error);
        throw error;
    }
}
```

### ‚ùå Mistake 4: Using async when not needed

```javascript
// WRONG (unnecessary async)
async function add(a, b) {
    return a + b;  // No async operation
}

// CORRECT
function add(a, b) {
    return a + b;
}
```

---

## async/await vs Promises

| Feature | Promises | async/await |
|---------|----------|-------------|
| **Syntax** | .then() chains | Looks synchronous |
| **Error handling** | .catch() | try/catch |
| **Debugging** | Harder | Easier |
| **Readability** | Can be complex | Very clear |
| **Composability** | Good with combinators | Good with logic |

**When to use what:**
- **Promises:** Simple chains, need combinators (Promise.all, etc.)
- **async/await:** Complex logic, multiple steps, easier to read

---

## Practice Exercises

Create `05-async-javascript/exercises/async-await-practice.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async/Await Practice</title>
</head>
<body>
    <h1>Check Console (F12)</h1>

    <script>
        // Helper function
        function delay(ms, value) {
            return new Promise(resolve => {
                setTimeout(() => resolve(value), ms);
            });
        }

        // Exercise 1: Basic async/await
        console.log("=== Exercise 1: Basic ===");
        
        async function exercise1() {
            console.log("Start");
            const result = await delay(1000, "Done!");
            console.log(result);
            console.log("End");
        }
        
        exercise1();

        // Exercise 2: Sequential operations
        console.log("\n=== Exercise 2: Sequential ===");
        
        async function exercise2() {
            const a = await delay(500, 5);
            const b = await delay(500, 10);
            const sum = a + b;
            console.log("Sum:", sum);
        }
        
        exercise2();

        // Exercise 3: Parallel operations
        console.log("\n=== Exercise 3: Parallel ===");
        
        async function exercise3() {
            const start = Date.now();
            
            const [a, b, c] = await Promise.all([
                delay(1000, "A"),
                delay(1000, "B"),
                delay(1000, "C")
            ]);
            
            const elapsed = Date.now() - start;
            console.log("Results:", a, b, c);
            console.log("Time:", elapsed + "ms");
        }
        
        exercise3();

        // Exercise 4: Error handling
        console.log("\n=== Exercise 4: Error Handling ===");
        
        async function exercise4() {
            try {
                const result = await Promise.reject("Error!");
                console.log(result);
            } catch (error) {
                console.error("Caught:", error);
            } finally {
                console.log("Cleanup done");
            }
        }
        
        exercise4();

        // Exercise 5: Real example
        console.log("\n=== Exercise 5: User Data ===");
        
        function fetchUser(id) {
            return delay(500, { id, name: `User ${id}` });
        }
        
        function fetchPosts(userId) {
            return delay(500, [
                { id: 1, title: "Post 1", userId },
                { id: 2, title: "Post 2", userId }
            ]);
        }
        
        async function loadUserWithPosts(userId) {
            try {
                console.log("Loading user...");
                const user = await fetchUser(userId);
                console.log("User:", user);
                
                console.log("Loading posts...");
                const posts = await fetchPosts(user.id);
                console.log("Posts:", posts);
                
                return { user, posts };
            } catch (error) {
                console.error("Failed to load:", error);
            }
        }
        
        loadUserWithPosts(1).then(data => {
            console.log("Complete:", data);
        });
    </script>
</body>
</html>
```

---

## Key Takeaways ‚úì

- [ ] `async` functions always return promises
- [ ] `await` pauses execution until promise resolves
- [ ] `await` only works inside `async` functions
- [ ] Use try/catch for error handling
- [ ] Use Promise.all() for parallel operations
- [ ] Sequential await is slower than parallel
- [ ] async/await makes code more readable
- [ ] Can mix async/await with .then/.catch

---

## What's Next?

You now know three ways to handle async code:
1. ‚úÖ Callbacks
2. ‚úÖ Promises
3. ‚úÖ async/await

**Next:** Learn the **Fetch API** to make real HTTP requests!

**Ready?** Open `04-fetch-api.md` üí™