# Module 05 - Lesson 2: Promises

## What Are Promises?

A **Promise** is an object representing the eventual completion (or failure) of an asynchronous operation.

**Think of it like a restaurant order:**
- ðŸŽ« You place an order (create promise)
- â³ Kitchen prepares food (pending)
- âœ… Food delivered (fulfilled/resolved)
- âŒ Order cancelled (rejected)

---

## Promise States

A Promise can be in one of three states:

```javascript
// PENDING - Initial state, neither fulfilled nor rejected
// FULFILLED - Operation completed successfully
// REJECTED - Operation failed

const promise = new Promise((resolve, reject) => {
    // Starts as PENDING
    
    setTimeout(() => {
        // After 1 second, becomes FULFILLED
        resolve("Success!");
    }, 1000);
});
```

**State flow:**
```
PENDING â†’ FULFILLED (success)
        â†“
       REJECTED (failure)
```

**Once settled (fulfilled/rejected), a promise cannot change state!**

---

## Creating Promises

### Basic Promise Creation

```javascript
const myPromise = new Promise((resolve, reject) => {
    // Do async work here
    
    const success = true;
    
    if (success) {
        resolve("Operation succeeded!");  // Fulfill the promise
    } else {
        reject("Operation failed!");      // Reject the promise
    }
});

// Using the promise
myPromise
    .then(result => {
        console.log("âœ…", result);  // Runs if resolved
    })
    .catch(error => {
        console.error("âŒ", error);  // Runs if rejected
    });
```

### Real Example: Simulated API Call

```javascript
function fetchUser(userId) {
    return new Promise((resolve, reject) => {
        console.log("Fetching user...");
        
        setTimeout(() => {
            // Simulate random success/failure
            const success = Math.random() > 0.2;
            
            if (success) {
                resolve({
                    id: userId,
                    name: "Ifeanyi Stanley",
                    email: "ifeanyi@example.com"
                });
            } else {
                reject(new Error("User not found"));
            }
        }, 1000);
    });
}

// Usage
fetchUser(1)
    .then(user => {
        console.log("User:", user);
    })
    .catch(error => {
        console.error("Error:", error.message);
    });
```

---

## Promise Chaining

**Power of promises:** Chain multiple async operations cleanly!

### Basic Chaining

```javascript
function fetchUser(id) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve({ id, name: "Ifeanyi" });
        }, 1000);
    });
}

function fetchPosts(userId) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve([
                { id: 1, title: "Post 1", userId },
                { id: 2, title: "Post 2", userId }
            ]);
        }, 1000);
    });
}

function fetchComments(postId) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve([
                { id: 1, text: "Great post!", postId },
                { id: 2, text: "Thanks!", postId }
            ]);
        }, 1000);
    });
}

// Clean chaining (no callback hell!)
fetchUser(1)
    .then(user => {
        console.log("1. User:", user);
        return fetchPosts(user.id);  // Return next promise
    })
    .then(posts => {
        console.log("2. Posts:", posts);
        return fetchComments(posts[0].id);
    })
    .then(comments => {
        console.log("3. Comments:", comments);
    })
    .catch(error => {
        console.error("Error:", error);
    });
```

**Key Rules:**
1. Always return a promise in `.then()` to continue chain
2. Return a value to pass to next `.then()`
3. One `.catch()` at end catches ALL errors in chain

---

## Error Handling

### Single Catch for Entire Chain

```javascript
fetchUser(1)
    .then(user => fetchPosts(user.id))
    .then(posts => fetchComments(posts[0].id))
    .then(comments => {
        console.log("All data loaded:", comments);
    })
    .catch(error => {
        // Catches errors from ANY step above
        console.error("Something went wrong:", error);
    });
```

### Multiple Catch Blocks

```javascript
fetchUser(1)
    .then(user => {
        console.log("User:", user);
        return fetchPosts(user.id);
    })
    .catch(error => {
        console.error("Failed to fetch user:", error);
        // Recover by returning default posts
        return [];
    })
    .then(posts => {
        console.log("Posts:", posts);
        return fetchComments(posts[0]?.id || 1);
    })
    .catch(error => {
        console.error("Failed to fetch posts:", error);
        return [];
    })
    .then(comments => {
        console.log("Comments:", comments);
    });
```

### Finally Block

Runs regardless of success or failure:

```javascript
let isLoading = true;

fetchUser(1)
    .then(user => {
        console.log("User:", user);
    })
    .catch(error => {
        console.error("Error:", error);
    })
    .finally(() => {
        isLoading = false;
        console.log("Loading complete!");
        // Always runs - perfect for cleanup!
    });
```

---

## Promise Static Methods

### Promise.resolve()

Create an immediately resolved promise:

```javascript
// Instead of this:
const promise1 = new Promise(resolve => resolve("Done"));

// Use this:
const promise2 = Promise.resolve("Done");

promise2.then(value => console.log(value));  // "Done"

// Useful for converting values to promises
function getData(useCache) {
    if (useCache) {
        return Promise.resolve("Cached data");  // Sync
    } else {
        return fetch("/api/data");  // Async
    }
}
```

### Promise.reject()

Create an immediately rejected promise:

```javascript
const error = Promise.reject(new Error("Something failed"));

error.catch(err => console.error(err.message));
// Something failed
```

### Promise.all()

Wait for ALL promises to resolve:

```javascript
const promise1 = Promise.resolve(3);
const promise2 = new Promise(resolve => setTimeout(() => resolve(42), 1000));
const promise3 = fetch("/api/data").then(res => res.json());

Promise.all([promise1, promise2, promise3])
    .then(([result1, result2, result3]) => {
        console.log("All done!");
        console.log("Results:", result1, result2, result3);
    })
    .catch(error => {
        // If ANY promise rejects, catch is called
        console.error("One failed:", error);
    });
```

**Use case:** Load multiple resources simultaneously

```javascript
function loadUserData(userId) {
    const userPromise = fetch(`/api/users/${userId}`);
    const postsPromise = fetch(`/api/posts?userId=${userId}`);
    const friendsPromise = fetch(`/api/friends?userId=${userId}`);
    
    return Promise.all([userPromise, postsPromise, friendsPromise])
        .then(responses => Promise.all(responses.map(r => r.json())))
        .then(([user, posts, friends]) => {
            return { user, posts, friends };
        });
}

loadUserData(1).then(data => {
    console.log("All data:", data);
});
```

### Promise.allSettled()

Wait for ALL promises to settle (resolve OR reject):

```javascript
const promises = [
    Promise.resolve("Success 1"),
    Promise.reject("Error 1"),
    Promise.resolve("Success 2"),
    Promise.reject("Error 2")
];

Promise.allSettled(promises)
    .then(results => {
        results.forEach((result, index) => {
            if (result.status === "fulfilled") {
                console.log(`${index}: âœ…`, result.value);
            } else {
                console.log(`${index}: âŒ`, result.reason);
            }
        });
    });

// Output:
// 0: âœ… Success 1
// 1: âŒ Error 1
// 2: âœ… Success 2
// 3: âŒ Error 2
```

**Use case:** When you need results from all operations, even failed ones

### Promise.race()

Resolves/rejects with first settled promise:

```javascript
const promise1 = new Promise(resolve => setTimeout(() => resolve("Slow"), 2000));
const promise2 = new Promise(resolve => setTimeout(() => resolve("Fast"), 500));

Promise.race([promise1, promise2])
    .then(result => {
        console.log("Winner:", result);  // "Fast"
    });
```

**Use case:** Timeout pattern

```javascript
function fetchWithTimeout(url, timeout) {
    const fetchPromise = fetch(url);
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Request timeout")), timeout);
    });
    
    return Promise.race([fetchPromise, timeoutPromise]);
}

fetchWithTimeout("/api/data", 5000)
    .then(response => response.json())
    .then(data => console.log("Data:", data))
    .catch(error => console.error("Error:", error.message));
```

### Promise.any()

Resolves with first fulfilled promise (ignores rejections):

```javascript
const promises = [
    Promise.reject("Error 1"),
    Promise.reject("Error 2"),
    Promise.resolve("Success!"),
    Promise.resolve("Another success")
];

Promise.any(promises)
    .then(result => {
        console.log("First success:", result);  // "Success!"
    })
    .catch(error => {
        console.error("All failed:", error);
    });
```

**Use case:** Fallback servers

```javascript
function fetchFromFastestServer(urls) {
    const promises = urls.map(url => fetch(url));
    return Promise.any(promises);
}

const mirrors = [
    "https://server1.com/api/data",
    "https://server2.com/api/data",
    "https://server3.com/api/data"
];

fetchFromFastestServer(mirrors)
    .then(response => response.json())
    .then(data => console.log("Data from fastest server:", data));
```

---

## Real-World Examples

### Example 1: Sequential vs Parallel

```javascript
// SEQUENTIAL (slow - one after another)
function sequentialFetch() {
    const start = Date.now();
    
    return fetchUser(1)
        .then(user => fetchPosts(user.id))
        .then(posts => fetchComments(posts[0].id))
        .then(comments => {
            const elapsed = Date.now() - start;
            console.log(`Sequential: ${elapsed}ms`);
            return comments;
        });
}

// PARALLEL (fast - all at once)
function parallelFetch() {
    const start = Date.now();
    
    return Promise.all([
        fetchUser(1),
        fetchPosts(1),
        fetchComments(1)
    ]).then(([user, posts, comments]) => {
        const elapsed = Date.now() - start;
        console.log(`Parallel: ${elapsed}ms`);
        return { user, posts, comments };
    });
}

// If each takes 1 second:
// Sequential: ~3000ms
// Parallel: ~1000ms
```

### Example 2: Retry Logic

```javascript
function retry(fn, maxAttempts, delay) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        
        function attempt() {
            attempts++;
            console.log(`Attempt ${attempts}/${maxAttempts}`);
            
            fn()
                .then(resolve)
                .catch(error => {
                    if (attempts < maxAttempts) {
                        console.log(`Failed, retrying in ${delay}ms...`);
                        setTimeout(attempt, delay);
                    } else {
                        reject(error);
                    }
                });
        }
        
        attempt();
    });
}

// Usage
retry(() => fetch("/api/unstable"), 3, 1000)
    .then(response => response.json())
    .then(data => console.log("Success:", data))
    .catch(error => console.error("Failed after 3 attempts:", error));
```

### Example 3: Progress Tracking

```javascript
function downloadFiles(urls, onProgress) {
    let completed = 0;
    
    const promises = urls.map(url => {
        return fetch(url)
            .then(response => response.blob())
            .then(blob => {
                completed++;
                onProgress(completed, urls.length);
                return blob;
            });
    });
    
    return Promise.all(promises);
}

// Usage
const fileUrls = [
    "/files/file1.pdf",
    "/files/file2.pdf",
    "/files/file3.pdf"
];

downloadFiles(fileUrls, (completed, total) => {
    const percent = (completed / total) * 100;
    console.log(`Progress: ${percent}%`);
})
.then(files => {
    console.log("All files downloaded:", files);
});
```

### Example 4: Caching with Promises

```javascript
const cache = new Map();

function fetchWithCache(url) {
    if (cache.has(url)) {
        console.log("ðŸ“¦ Cache hit!");
        return Promise.resolve(cache.get(url));
    }
    
    console.log("ðŸŒ Fetching from network...");
    return fetch(url)
        .then(response => response.json())
        .then(data => {
            cache.set(url, data);
            return data;
        });
}

// First call - network request
fetchWithCache("/api/users/1").then(user => {
    console.log("User:", user);
});

// Second call - from cache (instant!)
fetchWithCache("/api/users/1").then(user => {
    console.log("User:", user);
});
```

### Example 5: Waterfall Pattern

```javascript
function waterfall(tasks) {
    return tasks.reduce((promise, task) => {
        return promise.then(result => {
            return task(result);
        });
    }, Promise.resolve());
}

// Usage
const tasks = [
    () => {
        console.log("Task 1");
        return Promise.resolve("Result 1");
    },
    (previousResult) => {
        console.log("Task 2, got:", previousResult);
        return Promise.resolve("Result 2");
    },
    (previousResult) => {
        console.log("Task 3, got:", previousResult);
        return Promise.resolve("Result 3");
    }
];

waterfall(tasks).then(finalResult => {
    console.log("Final:", finalResult);
});
```

---

## Converting Callbacks to Promises

### Manual Conversion

```javascript
// Old callback style
function oldFetch(url, callback) {
    setTimeout(() => {
        callback(null, { data: "Success" });
    }, 1000);
}

// Convert to promise
function newFetch(url) {
    return new Promise((resolve, reject) => {
        oldFetch(url, (error, data) => {
            if (error) {
                reject(error);
            } else {
                resolve(data);
            }
        });
    });
}

// Now use with promises!
newFetch("/api/data")
    .then(data => console.log(data))
    .catch(error => console.error(error));
```

### Promisify Utility

```javascript
function promisify(fn) {
    return function(...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result);
                }
            });
        });
    };
}

// Usage
const promisedFetch = promisify(oldFetch);
promisedFetch("/api/data")
    .then(data => console.log(data));
```

---

## Common Mistakes

### âŒ Mistake 1: Forgetting to return

```javascript
// WRONG
fetchUser(1)
    .then(user => {
        fetchPosts(user.id);  // Forgot to return!
    })
    .then(posts => {
        console.log(posts);  // undefined
    });

// CORRECT
fetchUser(1)
    .then(user => {
        return fetchPosts(user.id);  // Return the promise
    })
    .then(posts => {
        console.log(posts);  // Now it works!
    });
```

### âŒ Mistake 2: Nested promises (promise hell)

```javascript
// WRONG (recreating callback hell)
fetchUser(1)
    .then(user => {
        fetchPosts(user.id)
            .then(posts => {
                fetchComments(posts[0].id)
                    .then(comments => {
                        console.log(comments);
                    });
            });
    });

// CORRECT (chain them)
fetchUser(1)
    .then(user => fetchPosts(user.id))
    .then(posts => fetchComments(posts[0].id))
    .then(comments => console.log(comments));
```

### âŒ Mistake 3: Not handling rejections

```javascript
// WRONG - unhandled rejection
fetchUser(1)
    .then(user => console.log(user));
// If it fails, you get an unhandled promise rejection!

// CORRECT - always catch
fetchUser(1)
    .then(user => console.log(user))
    .catch(error => console.error(error));
```

---

## Practice Exercises

Create `05-async-javascript/exercises/promises-practice.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promises Practice</title>
</head>
<body>
    <h1>Check Console (F12)</h1>

    <script>
        // Exercise 1: Create a promise
        console.log("=== Exercise 1: Basic Promise ===");
        
        const myPromise = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve("Promise resolved!");
            }, 1000);
        });
        
        myPromise.then(result => console.log(result));

        // Exercise 2: Promise chaining
        console.log("\n=== Exercise 2: Chaining ===");
        
        Promise.resolve(5)
            .then(num => {
                console.log("First:", num);
                return num * 2;
            })
            .then(num => {
                console.log("Second:", num);
                return num * 2;
            })
            .then(num => {
                console.log("Third:", num);
            });

        // Exercise 3: Error handling
        console.log("\n=== Exercise 3: Error Handling ===");
        
        Promise.reject(new Error("Oops!"))
            .then(result => console.log(result))
            .catch(error => console.error("Caught:", error.message))
            .finally(() => console.log("Cleanup done"));

        // Exercise 4: Promise.all
        console.log("\n=== Exercise 4: Promise.all ===");
        
        const p1 = Promise.resolve(10);
        const p2 = Promise.resolve(20);
        const p3 = Promise.resolve(30);
        
        Promise.all([p1, p2, p3])
            .then(([a, b, c]) => {
                console.log("Sum:", a + b + c);
            });

        // Exercise 5: Simulated API calls
        console.log("\n=== Exercise 5: Sequential API ===");
        
        function fetchUser(id) {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve({ id, name: `User ${id}` });
                }, 500);
            });
        }
        
        function fetchPosts(userId) {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve([
                        { id: 1, title: "Post 1", userId },
                        { id: 2, title: "Post 2", userId }
                    ]);
                }, 500);
            });
        }
        
        fetchUser(1)
            .then(user => {
                console.log("User:", user);
                return fetchPosts(user.id);
            })
            .then(posts => {
                console.log("Posts:", posts);
            })
            .catch(error => {
                console.error("Error:", error);
            });
    </script>
</body>
</html>
```

---

## Promise Comparison Table

| Method | Returns | Use When |
|--------|---------|----------|
| `Promise.all()` | Resolves when ALL resolve | Need all results, fail if any fails |
| `Promise.allSettled()` | Always resolves | Need all results, even failures |
| `Promise.race()` | First to settle | Need fastest result |
| `Promise.any()` | First to resolve | Need first success, ignore failures |

---

## Key Takeaways âœ“

- [ ] Promises have 3 states: pending, fulfilled, rejected
- [ ] Create promises with `new Promise(resolve, reject)`
- [ ] Chain promises with `.then()`
- [ ] Handle errors with `.catch()`
- [ ] Clean up with `.finally()`
- [ ] `Promise.all()` waits for all promises
- [ ] `Promise.race()` returns first settled
- [ ] Always return promises in `.then()` to continue chain
- [ ] One `.catch()` catches all chain errors

---

## What's Next?

Promises are great, but there's an even better syntax!

**async/await** makes async code look synchronous (next lesson!)

**Ready?** Open `03-async-await.md` ðŸ’ª