# Module 05 - Lesson 1: Introduction to Asynchronous JavaScript

## What is Asynchronous Programming?

JavaScript is **single-threaded** - it can only do one thing at a time. But what happens when you need to:
- Fetch data from a server (takes time)
- Wait for user input
- Load an image
- Read a file

**Asynchronous programming** lets JavaScript handle these time-consuming tasks without blocking other code!

---

## Synchronous vs Asynchronous

### Synchronous (Blocking)
Code runs line by line, waiting for each operation to complete:

```javascript
console.log("First");
console.log("Second");
console.log("Third");
// Output (in order):
// First
// Second
// Third
```

**Problem:** If "Second" takes 5 seconds, everything waits!

### Asynchronous (Non-Blocking)
Code continues running while waiting for operations:

```javascript
console.log("First");

setTimeout(() => {
    console.log("Second (after 2 seconds)");
}, 2000);

console.log("Third");

// Output:
// First
// Third
// Second (after 2 seconds)
```

**Benefit:** "Third" doesn't wait for the timeout!

---

## The Event Loop

JavaScript uses an **event loop** to handle async operations:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Call Stack            ‚îÇ  ‚Üê Currently executing code
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Web APIs              ‚îÇ  ‚Üê setTimeout, fetch, etc.
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Callback Queue        ‚îÇ  ‚Üê Waiting callbacks
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Event Loop            ‚îÇ  ‚Üê Checks if stack is empty
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**How it works:**
1. Code runs on the call stack
2. Async operations go to Web APIs
3. When complete, callbacks go to queue
4. Event loop moves callbacks to stack when empty

---

## setTimeout() and setInterval()

### setTimeout() - Run once after delay

```javascript
// Basic usage
setTimeout(() => {
    console.log("Hello after 2 seconds");
}, 2000);

// With function reference
function greet() {
    console.log("Greetings!");
}
setTimeout(greet, 1000);

// With parameters
setTimeout((name, age) => {
    console.log(`${name} is ${age} years old`);
}, 1000, "Ifeanyi", 25);

// Cancel timeout
const timeoutId = setTimeout(() => {
    console.log("This won't run");
}, 5000);

clearTimeout(timeoutId);  // Cancel it!
```

### setInterval() - Run repeatedly

```javascript
// Basic usage
let count = 0;
const intervalId = setInterval(() => {
    count++;
    console.log("Count:", count);
    
    if (count === 5) {
        clearInterval(intervalId);  // Stop after 5
    }
}, 1000);

// Real example: Clock
function updateClock() {
    const now = new Date();
    const time = now.toLocaleTimeString();
    console.log(time);
}

setInterval(updateClock, 1000);
```

---

## Callbacks

A **callback** is a function passed as an argument to be executed later.

### Basic Callback Pattern

```javascript
function fetchUserData(userId, callback) {
    console.log("Fetching user data...");
    
    // Simulate network delay
    setTimeout(() => {
        const user = {
            id: userId,
            name: "Ifeanyi",
            email: "ifeanyi@example.com"
        };
        
        callback(user);  // Execute callback with result
    }, 1000);
}

// Usage
fetchUserData(1, (user) => {
    console.log("User received:", user);
});
```

### Error-First Callbacks

Convention: First parameter is error, second is result:

```javascript
function fetchData(url, callback) {
    setTimeout(() => {
        // Simulate random error
        const hasError = Math.random() < 0.3;
        
        if (hasError) {
            callback(new Error("Failed to fetch data"), null);
        } else {
            callback(null, { data: "Success!" });
        }
    }, 1000);
}

// Usage
fetchData("api/users", (error, data) => {
    if (error) {
        console.error("Error:", error.message);
        return;
    }
    
    console.log("Data:", data);
});
```

---

## Callback Hell (Pyramid of Doom)

**Problem:** Nested callbacks become unreadable:

```javascript
// BAD: Callback Hell üò±
getUserData(userId, (userError, user) => {
    if (userError) {
        console.error(userError);
        return;
    }
    
    getPostsByUser(user.id, (postsError, posts) => {
        if (postsError) {
            console.error(postsError);
            return;
        }
        
        getComments(posts[0].id, (commentsError, comments) => {
            if (commentsError) {
                console.error(commentsError);
                return;
            }
            
            getUserLikes(user.id, (likesError, likes) => {
                if (likesError) {
                    console.error(likesError);
                    return;
                }
                
                // Finally do something...
                console.log("All data loaded!");
            });
        });
    });
});
```

**Issues:**
- Hard to read (nesting)
- Hard to maintain
- Error handling repeated
- Can't use try/catch
- Difficult to debug

**Solution:** Promises (next lesson!)

---

## Real-World Callback Examples

### Example 1: Simple Timer

```javascript
function countdown(seconds, callback) {
    console.log(`Countdown started: ${seconds} seconds`);
    
    const interval = setInterval(() => {
        seconds--;
        console.log(seconds);
        
        if (seconds === 0) {
            clearInterval(interval);
            callback();
        }
    }, 1000);
}

// Usage
countdown(5, () => {
    console.log("üöÄ Liftoff!");
});
```

### Example 2: Multiple Async Operations

```javascript
function parallel(tasks, callback) {
    const results = [];
    let completed = 0;
    
    tasks.forEach((task, index) => {
        task((result) => {
            results[index] = result;
            completed++;
            
            if (completed === tasks.length) {
                callback(results);
            }
        });
    });
}

// Usage
const tasks = [
    (cb) => setTimeout(() => cb("Task 1 done"), 1000),
    (cb) => setTimeout(() => cb("Task 2 done"), 500),
    (cb) => setTimeout(() => cb("Task 3 done"), 1500)
];

parallel(tasks, (results) => {
    console.log("All tasks completed:", results);
});
// Output after 1.5 seconds:
// All tasks completed: ["Task 1 done", "Task 2 done", "Task 3 done"]
```

### Example 3: Sequential Operations

```javascript
function sequence(tasks, callback) {
    let index = 0;
    const results = [];
    
    function runNext() {
        if (index >= tasks.length) {
            callback(results);
            return;
        }
        
        tasks[index]((result) => {
            results.push(result);
            index++;
            runNext();
        });
    }
    
    runNext();
}

// Usage
const sequentialTasks = [
    (cb) => setTimeout(() => cb("Step 1"), 1000),
    (cb) => setTimeout(() => cb("Step 2"), 500),
    (cb) => setTimeout(() => cb("Step 3"), 800)
];

sequence(sequentialTasks, (results) => {
    console.log("Sequence complete:", results);
});
// Output after ~2.3 seconds (1 + 0.5 + 0.8):
// Sequence complete: ["Step 1", "Step 2", "Step 3"]
```

### Example 4: Retry Logic

```javascript
function fetchWithRetry(url, maxRetries, callback) {
    let attempts = 0;
    
    function attempt() {
        attempts++;
        console.log(`Attempt ${attempts}...`);
        
        fetch(url)
            .then(response => response.json())
            .then(data => callback(null, data))
            .catch(error => {
                if (attempts < maxRetries) {
                    console.log("Retrying...");
                    setTimeout(attempt, 1000);
                } else {
                    callback(error, null);
                }
            });
    }
    
    attempt();
}

// Usage
fetchWithRetry("api/data", 3, (error, data) => {
    if (error) {
        console.error("Failed after 3 attempts:", error);
        return;
    }
    console.log("Data:", data);
});
```

---

## Common Async Patterns

### Pattern 1: Loading Indicator

```javascript
function loadDataWithIndicator(callback) {
    // Show loading
    console.log("‚è≥ Loading...");
    
    // Simulate fetch
    setTimeout(() => {
        // Hide loading
        console.log("‚úÖ Done!");
        
        callback({ data: "Sample data" });
    }, 2000);
}

loadDataWithIndicator((result) => {
    console.log("Result:", result);
});
```

### Pattern 2: Debounce (Wait for user to stop typing)

```javascript
function debounce(func, delay) {
    let timeoutId;
    
    return function(...args) {
        clearTimeout(timeoutId);
        
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

// Usage: Search as user types
const searchInput = document.getElementById("search");
const debouncedSearch = debounce((query) => {
    console.log("Searching for:", query);
    // Make API call here
}, 500);

searchInput.addEventListener("input", (e) => {
    debouncedSearch(e.target.value);
});
```

### Pattern 3: Throttle (Limit execution rate)

```javascript
function throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            
            setTimeout(() => {
                inThrottle = false;
            }, limit);
        }
    };
}

// Usage: Scroll event
const handleScroll = throttle(() => {
    console.log("Scroll position:", window.scrollY);
}, 1000);

window.addEventListener("scroll", handleScroll);
```

---

## Async Challenges

### Challenge 1: Understanding Order

```javascript
console.log("1");

setTimeout(() => {
    console.log("2");
}, 0);

console.log("3");

// What's the output?
// Answer: 1, 3, 2
// Why? setTimeout goes to Web API, even with 0ms delay
```

### Challenge 2: Loop with Async

```javascript
// WRONG ‚ùå
for (var i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);  // Prints: 3, 3, 3
    }, 1000);
}

// RIGHT ‚úÖ (Use let)
for (let i = 0; i < 3; i++) {
    setTimeout(() => {
        console.log(i);  // Prints: 0, 1, 2
    }, 1000);
}

// RIGHT ‚úÖ (Use closure)
for (var i = 0; i < 3; i++) {
    ((index) => {
        setTimeout(() => {
            console.log(index);  // Prints: 0, 1, 2
        }, 1000);
    })(i);
}
```

---

## Practice Exercises

Create `05-async-javascript/exercises/async-basics-practice.html`:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async JavaScript Practice</title>
</head>
<body>
    <h1>Check Console (F12)</h1>
    <button id="startTimer">Start 5-Second Timer</button>
    <button id="cancelTimer">Cancel Timer</button>

    <script>
        // Exercise 1: Basic setTimeout
        console.log("=== Exercise 1: setTimeout ===");
        console.log("Start");
        
        setTimeout(() => {
            console.log("After 1 second");
        }, 1000);
        
        console.log("End");

        // Exercise 2: Callback pattern
        console.log("\n=== Exercise 2: Callbacks ===");
        
        function simulateFetch(data, delay, callback) {
            console.log("Fetching...");
            setTimeout(() => {
                callback(data);
            }, delay);
        }
        
        simulateFetch("User Data", 1500, (result) => {
            console.log("Received:", result);
        });

        // Exercise 3: Error-first callback
        console.log("\n=== Exercise 3: Error Handling ===");
        
        function fetchWithError(shouldFail, callback) {
            setTimeout(() => {
                if (shouldFail) {
                    callback(new Error("Fetch failed!"), null);
                } else {
                    callback(null, { success: true });
                }
            }, 1000);
        }
        
        fetchWithError(false, (error, data) => {
            if (error) {
                console.error("Error:", error.message);
                return;
            }
            console.log("Data:", data);
        });

        // Exercise 4: Timer control
        const startBtn = document.getElementById("startTimer");
        const cancelBtn = document.getElementById("cancelTimer");
        let timerId;
        
        startBtn.addEventListener("click", () => {
            console.log("‚è±Ô∏è Timer started!");
            let count = 5;
            
            timerId = setInterval(() => {
                console.log(count);
                count--;
                
                if (count < 0) {
                    clearInterval(timerId);
                    console.log("‚è∞ Timer finished!");
                }
            }, 1000);
        });
        
        cancelBtn.addEventListener("click", () => {
            clearInterval(timerId);
            console.log("‚ùå Timer cancelled!");
        });

        // Exercise 5: Countdown function
        console.log("\n=== Exercise 5: Countdown ===");
        
        function countdown(seconds, onTick, onComplete) {
            const interval = setInterval(() => {
                onTick(seconds);
                seconds--;
                
                if (seconds < 0) {
                    clearInterval(interval);
                    onComplete();
                }
            }, 1000);
        }
        
        countdown(
            3,
            (remaining) => console.log(`${remaining}...`),
            () => console.log("üöÄ Blast off!")
        );
    </script>
</body>
</html>
```

---

## Key Takeaways ‚úì

- [ ] JavaScript is single-threaded but handles async operations
- [ ] Event loop manages async execution
- [ ] `setTimeout()` runs code once after delay
- [ ] `setInterval()` runs code repeatedly
- [ ] Callbacks are functions passed to be executed later
- [ ] Error-first callback pattern is conventional
- [ ] Callback hell makes code unreadable
- [ ] Debounce and throttle control execution frequency

---

## What's Next?

You've learned the **foundation** of async JavaScript!

**Problems with callbacks:**
- ‚ùå Callback hell (nested callbacks)
- ‚ùå Hard to handle errors
- ‚ùå Can't use try/catch
- ‚ùå Difficult to compose

**Solution:** **Promises!** (Next lesson)

Promises provide a much better way to handle async operations!

**Ready?** Open `02-promises.md` üí™

---

## Quick Reference

```javascript
// setTimeout
setTimeout(callback, delay);
clearTimeout(timeoutId);

// setInterval
setInterval(callback, delay);
clearInterval(intervalId);

// Error-first callback pattern
function asyncOperation(callback) {
    // callback(error, data)
}

// Usage
asyncOperation((error, data) => {
    if (error) {
        // Handle error
        return;
    }
    // Use data
});
```

**Remember:** Async doesn't mean parallel - JavaScript is still single-threaded!